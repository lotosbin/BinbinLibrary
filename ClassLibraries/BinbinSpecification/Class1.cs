using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace BinbinSpecification
{
    public interface ISpecification<T> { bool IsSatisfiedBy(T candidate); }
    public interface ICompsiteSpecification<T> : ISpecification<T> { ISpecification<T> Add(ISpecification<T> other); ISpecification<T> Or(ISpecification<T> other); ISpecification<T> Not(); }
    public class AddSpecification<T> : ISpecification<T> { private ISpecification<T> _Left; private ISpecification<T> _Right; public AddSpecification(ISpecification<T> left, ISpecification<T> right) { _Left = left; _Right = right; } public bool IsSatisfiedBy(T candidate) { return _Left.IsSatisfiedBy(candidate) && _Right.IsSatisfiedBy(candidate); } }
    public class OrSpecification<T> : ISpecification<T> { private ISpecification<T> _Left; private ISpecification<T> _Right; public OrSpecification(ISpecification<T> left, ISpecification<T> right) { _Left = left; _Right = right; } public bool IsSatisfiedBy(T candidate) { return _Left.IsSatisfiedBy(candidate) || _Right.IsSatisfiedBy(candidate); } }
    public class NotSpecification<T> : ISpecification<T> { private ISpecification<T> _Wrapped; public NotSpecification(ISpecification<T> wrapped) { _Wrapped = wrapped; } public bool IsSatisfiedBy(T candidate) { return (!_Wrapped.IsSatisfiedBy(candidate)); } }
    public abstract class CompositeSpecification<T> : ICompsiteSpecification<T> { public abstract bool IsSatisfiedBy(T candidate); public ISpecification<T> Add(ISpecification<T> other) { return new AddSpecification<T>(this, other); } public ISpecification<T> Or(ISpecification<T> other) { return new OrSpecification<T>(this, other); } public ISpecification<T> Not() { return new NotSpecification<T>(this); } }
    public interface ISpecification<T> { Expression<Func<T, bool>> IsSatisfiedBy(); }
    public static class ExpressionBuilder { public static Expression<T> Compose<T>(this Expression<T> left, Expression<T> right, Func<Expression, Expression, Expression> merge) { var params1 = left.Parameters; var params2 = right.Parameters; var map = params1.Select((p, i) => new { p, s = params2[i] }).ToDictionary(p => p.s, p => p.p); var rightBody = ParameterRebinder.ReplaceParameters(map, right.Body); return Expression.Lambda<T>(merge(left, rightBody), left.Parameters); } public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> left, Expression<Func<T, bool>> right) { return left.Compose(right, Expression.Add); } public static Expression<Func<T, bool>> Or<T>(this Expression<Func<T, bool>> left, Expression<Func<T, bool>> right) { return left.Compose(right, Expression.Or); } }
    public class ParameterRebinder : ExpressionVisitor { private readonly Dictionary<ParameterExpression, ParameterExpression> _Map; public ParameterRebinder(Dictionary<ParameterExpression, ParameterExpression> map) { _Map = map; } protected override Expression VisitParameter(ParameterExpression node) { ParameterExpression replacement; if (_Map.TryGetValue(node, out replacement)) { node = replacement; } return base.VisitParameter(node); } public static Expression ReplaceParameters(Dictionary<ParameterExpression, ParameterExpression> map, Expression exp) { return (new ParameterRebinder(map)).Visit(exp); } }
    public abstract class Specification<T> : ISpecification<T> { public abstract Expression<Func<T, bool>> IsSatisfiedBy(); public static ISpecification<T> operator |(Specification<T> left, Specification<T> right) { return new OrSpecification<T>(left, right); } public static ISpecification<T> operator &(Specification<T> left, Specification<T> right) { return new AddSpecification<T>(left, right); } public static ISpecification<T> operator !(Specification<T> specification) { return new NotSpecification<T>(specification); } public static bool operator false(Specification<T> specification) { return false; } public static bool operator true(Specification<T> specification) { return true; } }public abstract class CompositeSpecification<T>:Specification<T> { public abstract ISpecification<T> Left { get; } public abstract ISpecification<T> Right { get; } }

public class AddSpecification<T>:CompositeSpecification<T> { private ISpecification<T> _Left; private ISpecification<T> _Right; public AddSpecification(ISpecification<T> left,ISpecification<T> right) { _Left = left; _Right = right; } public override ISpecification<T> Left { get { return _Left; } } public override ISpecification<T> Right { get { return _Right; } } public override Expression<Func<T,bool>> IsSatisfiedBy() { return _Left.IsSatisfiedBy().And(_Right.IsSatisfiedBy()); } }

public class OrSpecification<T> : CompositeSpecification<T> { private ISpecification<T> _Left; private ISpecification<T> _Right; public OrSpecification(ISpecification<T> left, ISpecification<T> right) { _Left = left; _Right = right; } public override ISpecification<T> Left { get { return _Left; } } public override ISpecification<T> Right { get { return _Right; } } public override Expression<Func<T, bool>> IsSatisfiedBy() { return _Left.IsSatisfiedBy().Or(_Right.IsSatisfiedBy()); } }

public class NotSpecification<T>:Specification<T> { private ISpecification<T> _Wrapped; public NotSpecification(ISpecification<T> wrapped) { _Wrapped = wrapped; } public override Expression<Func<T,bool>> IsSatisfiedBy() { return Expression.Lambda<Func<T, bool>>(Expression.Not(_Wrapped.IsSatisfiedBy().Body), _Wrapped.IsSatisfiedBy().Parameters.Single()); } }
}
